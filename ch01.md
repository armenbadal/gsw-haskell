# Օր առաջին. Ֆակտորիալ

Այս կիրակի ես վերջապես որոշեցի սկսել ծանոթությունը [Haskell](https://www.haskell.org/) լեզվի հետ։ Haskel-ը _ֆունկցիանալ_ լեզու է. երբեմն ասում են, որ այն ֆունկցիոնալների մեջ ամենաֆունկցիոնալն է։ Ես, ինչ-որ տարրական պատկերացում ունենալով _ֆունկցիոնալ ծրագրավորման_ մասին, ինձ համար սահմանեցի հետևյալ առաջին խնդիրը.

_Ֆակտորիալ։_ Գրել ծրագիր, որ հրամանային տողից ստանում է որևէ դրական ամբողջ թիվ, ապա հաշվարկում և արտածում է այդ թվի ֆակտորիալը։

Բայց, մինչև խնդրի լուծմանն անցնելը, ես պիտի պատրաստեմ Haskell լեզվի միջավայրը, որում աշխատեցնելու եմ իմ գրած ծրագրերը։ Կարելի է, իհարկե, օգտագործել որևէ առցանց ծառայություն, ինչպիսիք են, օրինակ, [www.tutorialspoint.com](https://www.tutorialspoint.com/compile_haskell_online.php)-ը կամ [https://repl.it](https://repl.it/languages/haskell)-ը, բայց ես նախընտրում եմ ամեն ինչ ունենալ ձեռքի տակ՝ իմ մեքենայի վրա։

Իսկ իմ մեքենան _Raspberry Pi_ է` Debian-ի հիման վրա կառուցված օպերացիոն համակարգով։ _Haskell Platform_-ի [էջից](https://www.haskell.org/platform/linux.html#linux-debian) գտա, թե ինչպես է պետք տեղադրել Haskell-ի կոմպիլյատորն ու ինտերպրետատորը.

```bash
$ sudo apt-get install haskell-platform
```

Haskel Platform-ի կոմպիլյատորի և ինտերպրետատորի հաջող տեղադրված լինելը ստուգելու համար նախ հրամանային տողից աշխատեցեմ `ghci` ինտերպրետատորը.

```bash
$ ghci
GHCi, version 8.4.4: http://www.haskell.org/ghc/  :? for help
Prelude>
```

Հրավերքի տողում `Prelude` ցույց է տալիս, որ ինտերպրետատորը գործարկվել է և ակտիվ է _Prelude_ փաթեթը։ Խնդրեմ Հասկելին ցույց տալ π թվի արժեքը.

```bash
Prelude> pi
3.141592653589793
```

Կարծես թե աշխատում է։ Փորձեմ հենց այստեղ սահմանել ֆակտորիալը հաշվող ֆունկցիան՝ ամենապարզ մոտեցմամբ.

```
Prelude> factorial n = if n == 1 then 1 else n * factorial (n - 1)
```

Մի քանի օրինակներով համոզվեմ, որ սահմանած ֆունկցիան աշխատում է.

```
Prelude> factorial 1
1
Prelude> factorial 5
120
Prelude> factorial 10
3628800
Prelude> factorial 100
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
```

Հիմա այս ֆունկցիան գրեմ մի ֆայլի մեջ, օրինակ, `ex0.hs` անունով, ու փորձեմ այդ ֆայլը թարգմանել Հասկելի կոմպիլյատորով։

```Haskell
-- Իմ առաջին ծրագիրը

factorial :: Integer -> Integer
factorial n = if n == 1 then 1 else n * factorial (n - 1)
```

Այստեղ ֆունկցիայի սահմանումից առաջ ավելացրել եմ նաև դրա _վերնագիրը_ (կամ _նկարագրությունը_)։ Այդ նկարագրությամբ տրվում է ֆունկցիայի տիպը. `::` սիմվոլից ձախ գրված է ֆունկցիայի անունը՝ `factorial`, իսկ աջ կողմում՝ արգումենտի ու վերադարձվող արժեքի տիպերը։ Այսինքն՝ ֆունկցիան ստանում է `Integer` տիպի արգումենտ և վերադարձնում է `Integer` տիպի արժեք։ Երկրորդ տողում հենց ֆունկցիայի սահմանումն է. `=` սիմվոլից ձախ ֆունկցիայի անունն ու արգումենտն է, իսկ աջ կողմում՝ մարմինը, որը տվյալ դեպքում պարզ ճյուղավորման արտահայտություն է։

Haskell Platform-ում կոմպիլյատորը `ghc`—ն է։ Աշխատեցնում եմ՝ մուտքին տալով `ex0.hs` ֆայլը.

```bash
$ ghc ex0.hs
[1 of 1] Compiling Main             ( ex0.hs, ex0.o )

ex0.hs:1:1: error:
    The IO action ‘main’ is not defined in module ‘Main’
  |
1 |
  | ^
```

Սխալի հաղորդագրությունն ասում է, որ `Main` մոդուլում սահմանված չէ `main` գործողությունը։ Բանից պարզվում է, որ Հասկելի կոմպիլյատորը նույնպես (ինչպես, օրինակ, Սի լեզվի կոմպիլյատորը) որպես մուտքի կետ է համարում `main` գործողությունը։ Հիմա `ex0.hs` ֆայլում ավելացնում եմ `main` գործողությունն այնպես, որ այն արտածի `12`-ի ֆակտորիալը.

```Haskell
-- Իմ առաջին ծրագիրը
factorial n = if n == 1 then 1 else n * factorial (n - 1)

-- Մուտքի կետը
main =
    print (factorial 12)
```

Նորից փորձեմ թարգմանել։ Ի դեպ, Հասկել լզվում `--` սիմվոլով սկսվում են մեկնաբանությունները։

```bash
$ ghc ex0.hs
[1 of 1] Compiling Main             ( ex0.hs, ex0.o )
Linking ex0 ...
```

Արդեն ամեն ինչ լավ է։ Իմ գրած ծրագիրը թարգմանվեց (compile), կապակցվեց (link), և հիմա կարող եմ աշխատեցնել ու տեսնել արդյունքը.

```bash
$ ./ex0
479001600
```

Բայց այս ծրագիրը կարողանում է հաշվել ու տպել միայն `12`-ի ֆակտորիալը։ Իսկ ես ուզում եմ, որ այն կարողանա հաշվել հրամանային տողում տրված թվի ֆակտորիալը։ ՄԻ քիչ քչփորելուց հետո պարզեցի, որ Հասկել ծրագրում գրամանային տողի պարամետրերը կարելի է վերցնել `System.Environment` մոդուլի `getArgs` գործողությամբ։ Օրինակ, հետևյալ ծրագիրը (գրառված `ex1.hs` ֆայլում) արտածում է հրամանային տողում տրված պարամետրերի ցուցակը.

```Haskell
-- Հրամանային տողի պարամետրերի ցուցադրություն

import System.Environment

main = do
    args <- getArgs
    print args
```

Ահա թարգմանության ու կատարման մի քանի օրինակ.

```bash
$ ./ex1
[]
$ ./ex1 a
["a"]
$ ./ex1 a bb
["a","bb"]
$ ./ex1 a bb ccc
["a","bb","ccc"]
$ ./ex1 1 22 333
["1","22","333"]
```

Այստեղից երևում է, որ հրամանային տողի պարամետրերը ծրագրում երևում են _տեքստային_ արժեքների ցուցակի տեսքով։ Ես պետք է թվի տեքստային ներկայացումից ստանամ դրա _թվային արժեքը_, ապա այդ արժեքի նկատմամբ կիրառեմ `factorial` ֆունկցիան:

Հասկելի `read` ֆուկցիան տեքսից «կարդում» է որևէ տիպի արժեք։ Այդ տիպը տրվում է ֆունկցիայի կանչի հետ՝ `::` սիմվոլոլից հետո։ Օրինակ, «`read "12" :: Int`» արտահայտությունը `"12"` տողից կարդում է `Int` տիպի `12` արժեքը։ «`read "12" :: Float`» արտահայտությունը նույն տողից կարդում է `12.0` արժեքը՝ `Float` տիպի։

Այսպիսով, ես պետք է վերցնեմ հրամանային տողի պարամետրերի ցուցակի առաջին տարրը (`head` ֆունկցիայիով), դրա նկատմամբ կիրառեմ `read` ֆունկցիան՝ `Integer` տիպի համար, ստացված արժեքի նկատմամբ կիրառեմ `factorial`-ը ու տպեմ ստացված արժեքը։ Ահա այսպիսի մի արտահայտություն `main` ֆունկցիայում.

```Haskell
print (factorial (read (head args) :: Integer))
```

Ձևափոխված `ex0.hs` ծրագիրը կունենա հետևյալ վերջնական տեսքը.

```Haskell
import System.Environment

-- Ֆակտորիալի հաշվարկը
factorial :: Integer -> Integer
factorial n = 
    if n == 1 
    then 1
    else n * factorial (n - 1)

-- Մուտքի կետ
main :: IO ()
main = do
    args <- getArgs
    print (factorial (read (head args) :: Integer))
```

Լավ. տեսնենք, թե սա ինչպես է աշխատում։

```bash
$ ghc ex0.hs
[1 of 1] Compiling Main             ( ex0.hs, ex0.o )
Linking ex0 ...
$ ./ex0 2
2
$ ./ex0 12
479001600
$ ./ex0 20
2432902008176640000
$ ./ex0 40
815915283247897734345611269596115894272000000000
```

Լավ էլ աշխատում է։ Բայց, իհարկե, թերություններ կան։ Առաջին թերությունը տեխնիկական է. դիտարկված չէ այն դեպքը, երբ հրամանային տողում ոչինչ տրված չէ։ Օրինակ, եթե աշխատեցնեմ ծրագիրը՝ հրամանային տողում ոչինչ չտալով, ապա կստանամ հաղորդագրություն այն մասին, որ `head` ֆունկցիային տրված է դատարկ ցուցակ.

```bash
$ ./ex0
ex0: Prelude.head: empty list
```

Սա պետք է ուղղել՝ `main` գործողության մեջ պայման գրելով։ Այսպես.

```Haskell
main = do
    args <- getArgs
    if not (null args)
    then print (factorial (read (head args) :: Integer))
    else putStrLn "Ոչինչ տրված չէ։"
```

Հիմա եթե ծրագիրն աշխատեցնեմ դատարկ հրամանային տողով, ապա որպես պատասխան կստանամ «`Ոչինչ տրված չէ։`»։

Հաջորդիվ. թերևս Հասկել լեզվով գրող ոչ մի ծրագրավորող թվի ֆակտորիալը հաշվող ֆունկցիան չի գրի այնպես, ինչպես ես գրել եմ։ Վարպետ Հասկել-ծրագրավորողը պարզապես կգրի.

```Haskell
factorial :: Integer -> Integer
factorial n = product [1 .. n]
```

Եվ վերջ։ Այստեղ գրված է ֆակտորիալի բառացի սահմանումը՝ այն `1`-ից `n` թվերի (`[1 .. n]`) արտադրյալն է (`product`):



